---
title: "Методы расширения (Руководство по программированию в C#) | Microsoft Docs"
ms.custom: ""
ms.date: "11/24/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-csharp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "методы расширения [C#]"
  - "методы [C#], добавление к существующим типам"
  - "методы [C#], расширение"
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
caps.latest.revision: 35
caps.handback.revision: 35
author: "BillWagner"
ms.author: "wiwagn"
manager: "wpickett"
translationtype: Human Translation
---
# Методы расширения (Руководство по программированию в C#)
[!INCLUDE[vs2017banner](../../../csharp/includes/vs2017banner.md)]

Методы расширения позволяют "добавлять" методы в существующие типы без создания нового производного типа, перекомпиляции и иного изменения первоначального типа.  Методы расширения представляют собой особую разновидность статического метода, но вызываются так же, как методы экземпляра в расширенном типе.  Для клиентского кода, написанного на языках C\# и Visual Basic, нет видимого различия между вызовом метода расширения и вызовом методов, фактически определенных в типе.  
  
 Самые обычные методы расширения — стандартные операторы запросов [!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq_md.md)], которые добавляют функции запросов в существующие типы <xref:System.Collections.IEnumerable?displayProperty=fullName> и <xref:System.Collections.Generic.IEnumerable%601?displayProperty=fullName>.  Для использования стандартных операторов запросов их необходимо ввести в область действия с помощью директивы `using System.Linq`.  Тогда каждый тип, реализующий тип <xref:System.Collections.Generic.IEnumerable%601>, будет иметь методы экземпляра, в частности <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A> и т. д.  Эти дополнительные методы можно видеть в завершении операторов IntelliSense при вводе точки после экземпляра типа <xref:System.Collections.Generic.IEnumerable%601>, например <xref:System.Collections.Generic.List%601> или <xref:System.Array>.  
  
 В следующем примере показано, как вызывать метод стандартного оператора запроса `OrderBy` для массива целых чисел.  Выражение в скобках называется лямбда\-выражением.  Многие стандартные операторы запроса принимают лямбда\-выражения в качестве параметров, но это необязательно для методов расширения.  Дополнительные сведения см. в разделе [Лямбда\-выражения](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).  
  
 [!CODE [csProgGuideExtensionMethods#3](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideExtensionMethods#3)]  
  
 Методы расширения определяются как статические методы, но вызываются с помощью синтаксиса обращения к методу экземпляра.  Их первый параметр определяет, с каким типом оперирует метод, и параметру предшествует модификатор [this](../../../csharp/language-reference/keywords/this.md).  Методы расширения находятся в области действия, только если пространство имен было явно импортировано в исходный код с помощью директивы `using`.  
  
 В приведенном ниже примере показан метод расширения, определенный для класса <xref:System.String?displayProperty=fullName>.  Обратите внимание, что этот метод определяется внутри невложенного, неуниверсального статического класса.  
  
 [!CODE [csProgGuideExtensionMethods#4](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideExtensionMethods#4)]  
  
 Метод расширения `WordCount` можно ввести в область действия с помощью следующей директивы `using`:  
  
```  
using ExtensionMethods;  
```  
  
 Его можно вызвать из приложения с помощью следующего синтаксиса:  
  
```  
string s = "Hello Extension Methods";  
int i = s.WordCount();  
```  
  
 В созданном коде метод расширения вызывается с помощью синтаксиса обращения к методу экземпляра.  Однако промежуточный язык \(IL\), создаваемый компилятором, преобразует код в вызов статического метода.  Поэтому принцип инкапсуляции фактически не нарушается.  Фактически, методы расширения не могут получать доступ к частным переменным типа, для расширения которого они используются.  
  
 Дополнительные сведения см. в разделе [Практическое руководство. Реализация и вызов пользовательского метода расширения](../../../csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method.md).  
  
 Вообще, обычно гораздо чаще вызываются методы расширения, чем реализуются собственные методы.  Так как методы расширения вызываются с помощью синтаксиса обращения к методу экземпляра, для использования их из клиентского кода специальные знания не требуются.  Чтобы включить методы расширения для определенного типа, необходимо просто добавить директиву `using` для пространства имен, в котором эти методы определяются.  Например, чтобы использовать стандартные операторы запроса, нужно добавить в код следующую директиву `using`:  
  
```  
using System.Linq;  
```  
  
 \(Также может потребоваться добавить ссылку на библиотеку System.Core.dll.\) Обратите внимание, что стандартные операторы запроса теперь появляются в IntelliSense в виде дополнительных методов, доступных для большинства типов <xref:System.Collections.Generic.IEnumerable%601>.  
  
> [!NOTE]
>  Хотя стандартные операторы запросов не появляются в IntelliSense для типа <xref:System.String>, они все равно доступны.  
  
## Привязка методов расширения во время компиляции  
 Методы расширения можно использовать для расширения класса или интерфейса, но не для их переопределения.  Метод расширения, имеющий те же имя и сигнатуру, что и интерфейс или метод класса, никогда не вызывается.  Во время компиляции методы расширения всегда имеют более низкий приоритет, чем методы экземпляра, определенные в самом типе.  Другими словами, если тип имеет метод `Process(int i)`, а также есть метод расширения с такой же сигнатурой, компилятор будет всегда выполнять привязку к методу экземпляра.  Если компилятор обнаруживает вызов метода, он сначала ищет совпадения с методами экземпляра типа.  Если такое совпадение не найдено, компилятор выполняет поиск методов расширения, определенных для соответствующего типа, и создает привязку к первому обнаруженному методу расширения.  В следующем примере кода демонстрируется, как компилятор определяет, к какому методу расширения или методу экземпляра необходимо выполнить привязку.  
  
## Пример  
 В следующем примере демонстрируются правила, которые компилятор C\# соблюдает при определении того, к чему необходимо привязать вызов метода — к методу экземпляра типа или к методу расширения.  Статический класс `Extensions` содержит методы расширения, определяемые для любого типа, реализующего интерфейс `IMyInterface`.  Все три класса — `A`, `B` и `C` — реализуют этот интерфейс.  
  
 Метод расширения `MethodB` никогда не вызывается, потому что его имя и сигнатура точно совпадают с методами, уже реализованными этими классами.  
  
 Если компилятор не может найти метод экземпляра с совпадающей сигнатурой, он выполняет привязку к совпадающему методу расширения, если такой существует.  
  
 [!CODE [csProgGuideExtensionMethods#5](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideExtensionMethods#5)]  
  
## Общие рекомендации  
 В общем, методы расширения рекомендуется реализовывать в ограниченном количестве и только при необходимости.  Когда это возможно, клиентский код, служащий для расширения существующего типа, должен осуществлять расширение путем создания нового типа, производного от существующего.  Дополнительные сведения см. в разделе [Наследование](../../../csharp/programming-guide/classes-and-structs/inheritance.md).  
  
 При использовании метода расширения для расширения типа, исходный код которого невозможно изменить, возникает риск того, что изменение в реализации типа вызовет сбой метода расширения.  
  
 В случае реализации методов расширения для какого\-либо типа необходимо помнить о следующих фактах.  
  
-   Метод расширения никогда не будет вызван, если он имеет ту же сигнатуру, что и метод, определенный в типе.  
  
-   Методы расширения вводятся в область действия на уровне пространства имен.  Например, при наличии нескольких статических классов, содержащих методы расширения в единственном пространстве имен с именем `Extensions`, все они будут введены в область действия директивой `using Extensions;`.  
  
 Для реализованной библиотеки классов не следует использовать методы расширения во избежание увеличения номера версии сборки.  Если требуется добавить значительную функциональность в библиотеку, владельцем исходного кода которой вы являетесь, необходимо соблюдать стандартные правила .NET Framework по управлению версиями сборок.  Дополнительные сведения см. в разделе [Управление версиями сборок](../Topic/Assembly%20Versioning.md).  
  
## См. также  
 [Руководство по программированию на C\#](../../../csharp/programming-guide/index.md)   
 [Parallel Programming Samples \(содержится множество примеров методов расширения\)](http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)   
 [Лямбда\-выражения](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)   
 [Standard Query Operators Overview](../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)   
 [Conversion rules for Instance parameters and their impact](http://go.microsoft.com/fwlink/?LinkId=112385)   
 [Extension methods Interoperability between languages](http://go.microsoft.com/fwlink/?LinkId=112386)   
 [Extension methods and Curried Delegates](http://go.microsoft.com/fwlink/?LinkId=112387)   
 [Extension method Binding and Error reporting](http://go.microsoft.com/fwlink/?LinkId=112388)