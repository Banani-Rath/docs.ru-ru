---
title: "Разделяемые классы и методы (Руководство по программированию в C#) | Microsoft Docs"
ms.custom: ""
ms.date: "11/24/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-csharp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "C# - язык, разделяемые классы и методы"
  - "разделяемые классы [C#]"
  - "разделяемые методы [C#]"
ms.assetid: 804cecb7-62db-4f97-a99f-60975bd59fa1
caps.latest.revision: 35
caps.handback.revision: 35
author: "BillWagner"
ms.author: "wiwagn"
manager: "wpickett"
translationtype: Human Translation
---
# Разделяемые классы и методы (Руководство по программированию в C#)
[!INCLUDE[vs2017banner](../../../csharp/includes/vs2017banner.md)]

Имеется возможность разделить определение [класса](../../../csharp/language-reference/keywords/class.md) или [структуры](../../../csharp/language-reference/keywords/struct.md), [интерфейса](../../../csharp/language-reference/keywords/interface.md) или метода между двумя или более исходными файлами.  Каждый исходный файл содержит определение типа или метода, и все части объединяются при компиляции приложения.  
  
## Разделяемый класс  
 Существует несколько ситуаций, при которых желательно разделение определения класса:  
  
-   При работе над большими проектами распределение класса между различными файлами позволяет нескольким программистам работать с ним одновременно.  
  
-   При работе с использованием автоматически создаваемого источника код можно добавлять в класс без повторного создания файла источника.  Система Visual Studio использует этот подход при создании форм Windows Forms, программы оболочки веб\-службы и т.д.  Можно создать программу, использующую эти классы, без необходимости изменения файла, созданного системой Visual Studio.  
  
-   Чтобы разделить определение класса, используйте модификатор ключевого слова [partial](../../../csharp/language-reference/keywords/partial-type.md), как показано ниже:  
  
 [!CODE [csProgGuideObjects#26](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideObjects#26)]  
  
 Ключевое слово `partial` указывает на то, что другие части класса, структуры или интерфейса могут быть определены в пространстве имен.  Все части должны использовать ключевое слово `partial`.  Для формирования окончательного типа все части должны быть доступны во время компиляции.  Все части должны иметь одинаковые специальные возможности, например `public`, `private` и т.д.  
  
 Если какая\-либо из частей объявлена абстрактной, то весь тип будет считаться абстрактным.  Если какая\-либо из частей объявлена запечатанной, то весь тип будет считаться запечатанным.  Если какая\-либо из частей объявляет базовый тип, то весь тип будет наследовать данный класс.  
  
 Все части, указывающие базовый класс, должны быть согласованы друг с другом, а части, не использующие базовый класс, все равно наследуют базовый тип.  Части могут указывать различные базовые интерфейсы, и окончательный тип будет реализовывать все интерфейсы, перечисленные во всех разделяемых объявлениях.  Любые члены класса, структуры или интерфейса, объявленные в разделяемом объявлении, доступны для всех остальных частей.  Окончательный тип представляет собой комбинацию всех частей, выполненную во время компиляции.  
  
> [!NOTE]
>  Модификатор `partial` нельзя использовать для объявлений делегата или перечисления.  
  
 В следующем примере показано, что вложенные типы могут быть разделяемыми, даже если тип, в который они вложены, не является разделяемым.  
  
 [!CODE [csProgGuideObjects#25](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideObjects#25)]  
  
 При компиляции атрибуты определений разделяемого типа объединяются.  В качестве примера рассмотрим следующие объявления:  
  
 [!CODE [csProgGuideObjects#23](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideObjects#23)]  
  
 Они эквивалентны следующим объявлениям:  
  
 [!CODE [csProgGuideObjects#24](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideObjects#24)]  
  
 Следующие элементы объединяются изо всех определений разделяемого типа:  
  
-   XML\-комментарии;  
  
-   интерфейсы;  
  
-   атрибуты параметров универсального типа;  
  
-   атрибуты классов;  
  
-   members  
  
 В качестве примера рассмотрим следующие объявления:  
  
 [!CODE [csProgGuideObjects#21](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideObjects#21)]  
  
 Они эквивалентны следующим объявлениям:  
  
 [!CODE [csProgGuideObjects#22](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideObjects#22)]  
  
### Ограничения  
 Имеется несколько правил, которые необходимо выполнять при работе с определениями разделяемого класса:  
  
-   Все определения разделяемого типа, являющиеся частями одного и того же типа, должны изменяться с использованием модификатора `partial`.  Например, следующие объявления класса приведут к появлению ошибки:  
  
     [!CODE [csProgGuideObjects#20](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideObjects#20)]  
  
-   Модификатор `partial` должен находиться непосредственно перед ключевыми словами `class`, `struct` или `interface`.  
  
-   В определениях разделяемого типа могут присутствовать вложенные разделяемые типы, что показано в следующем примере:  
  
     [!CODE [csProgGuideObjects#19](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideObjects#19)]  
  
-   Все определения разделяемого типа, являющиеся частями одного и того же типа, должны быть определены в одной сборке и в одном модуле \(EXE\-файл или DLL\-файл\).  Разделяемые определения не могут находиться в разных модулях.  
  
-   Имя класса и параметры универсального типа должны соответствовать всем определениям разделяемого типа.  Универсальные типы могут быть разделяемыми.  Все объявления разделяемого типа должны использовать одинаковые имена параметров в одном и том же порядке.  
  
-   Приведенные ниже ключевые слова необязательно должны присутствовать в определении разделяемого типа, но если они присутствуют в одном определении разделяемого типа, то не должны конфликтовать с ключевыми словами, указанными в других определениях того же разделяемого типа:  
  
    -   [public](../../../csharp/language-reference/keywords/public.md)  
  
    -   [private](../../../csharp/language-reference/keywords/private.md)  
  
    -   [protected](../../../csharp/language-reference/keywords/protected.md)  
  
    -   [internal](../../../csharp/language-reference/keywords/internal.md)  
  
    -   [abstract](../../../csharp/language-reference/keywords/abstract.md)  
  
    -   [sealed](../../../csharp/language-reference/keywords/sealed.md)  
  
    -   базовый класс  
  
    -   модификатор [new](../../../csharp/language-reference/keywords/new.md) \(вложенные части\)  
  
    -   универсальные ограничения  
  
         Дополнительные сведения см. в разделе [Ограничения параметров типа](../../../csharp/programming-guide/generics/constraints-on-type-parameters.md).  
  
## Пример 1  
  
### Описание  
 В следующем примере поля и конструктор класса `CoOrds` объявлены в одном определении разделяемого класса, а член `PrintCoOrds` — в другом определении разделяемого класса.  
  
### Код  
 [!CODE [csProgGuideObjects#17](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideObjects#17)]  
  
## Пример 2  
  
### Описание  
 В следующем примере показано, что можно также разработать разделяемые структуры и интерфейсы.  
  
### Код  
 [!CODE [csProgGuideObjects#18](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideObjects#18)]  
  
## Разделяемые методы  
 Разделяемый класс или структура могут содержать разделяемый метод.  Одна часть класса содержит сигнатуру метода.  В той же или в другой части можно определить дополнительную реализацию.  Если реализация не предоставлена, то метод и все вызовы метода удаляются во время компиляции.  
  
 Разделяемые методы позволяют разработчику одной части класса определить метод, схожий с событием.  Разработчик другой части класса может решить, реализовывать этот метод или нет.  Если метод не реализован, то компилятор удаляет сигнатуру метода и все вызовы этого метода.  Вызовы метода, включая любые результаты, которые могли бы произойти от оценки аргументов в вызовах, не имеют эффекта во время выполнения.  Таким образом, любой код в разделяемом классе может свободно использовать разделяемый метод, даже если реализация не предоставлена.  Во время компиляции и выполнения программы не возникнут никакие ошибки, если метод будет вызван, но не реализован.  
  
 Разделяемые методы особенно полезны для настройки автоматически созданного кода.  Они позволяют зарезервировать имя и сигнатуру метода, чтобы автоматически созданный код мог вызвать метод, а разработчик мог сам решить, реализовывать этот метод или нет.  Как и разделяемые классы, разделяемые методы позволяют организовать совместную работу автоматически созданного кода и кода, созданного человеком, без дополнительных затрат во время выполнения.  
  
 Объявление разделяемого метода состоит из двух частей: определения и реализации.  Они могут находиться в разных частях или в одной и той же части разделяемого класса.  Если объявление реализации отсутствует, то компилятор оптимизирует код, удаляя как объявление определения, так и все вызовы метода.  
  
```  
// Definition in file1.cs  
partial void onNameChanged();  
  
// Implementation in file2.cs  
partial void onNameChanged()  
{  
  // method body  
}  
```  
  
-   Объявления разделяемого метода должны начинаться с контекстно\-зависимого ключевого слова [partial](../../../csharp/language-reference/keywords/partial-type.md), а метод должен возвращать значение типа [void](../../../csharp/language-reference/keywords/void.md).  
  
-   Разделяемые методы могут иметь параметры [ref](../../../csharp/language-reference/keywords/ref.md), но не могут иметь параметры [out](../../../csharp/language-reference/keywords/out.md).  
  
-   Разделяемые методы неявно имеют модификатор [private](../../../csharp/language-reference/keywords/private.md) и поэтому не могут иметь модификатор [virtual](../../../csharp/language-reference/keywords/virtual.md).  
  
-   Разделяемые методы не могут иметь модификатор [extern](../../../csharp/language-reference/keywords/extern.md), поскольку наличие тела определяет, выполняется ли их определение или реализация.  
  
-   Разделяемые методы могут иметь модификаторы [static](../../../csharp/language-reference/keywords/static.md) и [unsafe](../../../csharp/language-reference/keywords/unsafe.md).  
  
-   Разделяемые типы могут быть универсальными.  Ограничения помещаются в ту часть обяъвления разделяемого метода, где находится определение, и могут дополнительно повторяться в разделе реализации.  Имена параметров и типов параметров необязательно должны совпадать в объявлении реализации и в объявлении определения.  
  
-   Можно использовать [делегат](../../../csharp/language-reference/keywords/delegate.md) в качестве определенного и реализованного разделяемого метода, но его нельзя использовать в качестве разделяемого метода, который только определен.  
  
## Спецификация языка C\#  
 [!INCLUDE[CSharplangspec](../../../csharp/language-reference/keywords/includes/csharplangspec_md.md)]  
  
## См. также  
 [Руководство по программированию на C\#](../../../csharp/programming-guide/index.md)   
 [Классы](../../../csharp/programming-guide/classes-and-structs/classes.md)   
 [Структуры](../../../csharp/programming-guide/classes-and-structs/structs.md)   
 [Интерфейсы](../../../csharp/programming-guide/interfaces/index.md)   
 [partial \(тип\)](../../../csharp/language-reference/keywords/partial-type.md)