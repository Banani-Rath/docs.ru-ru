---
title: "Наследование (Руководство по программированию на C#) | Microsoft Docs"
ms.custom: ""
ms.date: "11/24/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-csharp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "абстрактные классы [C#]"
  - "абстрактные методы [C#]"
  - "C# - язык, наследование"
  - "производные классы [C#]"
  - "наследование [C#]"
  - "виртуальные методы [C#]"
ms.assetid: 81d64ee4-50f9-4d6c-a8dc-257c348d2eea
caps.latest.revision: 38
caps.handback.revision: 38
author: "BillWagner"
ms.author: "wiwagn"
manager: "wpickett"
translationtype: Human Translation
---
# Наследование (Руководство по программированию на C#)
[!INCLUDE[vs2017banner](../../../csharp/includes/vs2017banner.md)]

Наследование, вместе с инкапсуляцией и полиморфизмом, является одной из трех основных характеристик \(или *базовых понятий*\) объектно\-ориентированного программирования.  Наследование позволяет создавать новые классы, которые повторно используют, расширяют и изменяют поведение, определенное в других классах.  Класс, члены которого наследуются, называется *базовым классом*, а класс, который наследует эти члены, называется *производным классом*.  Производный класс может иметь только один непосредственный базовый класс.  Однако наследование является транзитивным.  Если ClassC является производным от ClassB, и ClassB является производным от ClassA, ClassC наследует члены, объявленные в ClassB и ClassA.  
  
> [!NOTE]
>  Структуры не поддерживают наследование, но они могут реализовывать интерфейсы.  Дополнительные сведения см. в разделе [Интерфейсы](../../../csharp/programming-guide/interfaces/index.md).  
  
 Концептуально, производный класс является специализацией базового класса.  Например, при наличии базового класса `Animal`, возможно наличие одного производного класса, который называется `Mammal`, и еще одного производного класса, который называется `Reptile`.  `Mammal` является `Animal`, а `Reptile` является `Animal`, но каждый производный класс представляет разные специализации базового класса.  
  
 При определении класса для наследования от другого класса, производный класс явно получает все члены базового класса, за исключением его конструкторов и деструкторов.  Производный класс может таким образом повторно использовать код в базовом классе без необходимости в его повторной реализации.  В производном классе можно добавить больше членов.  Таким образом, производный класс расширяет функциональность базового класса.  
  
 Ниже иллюстрируется класс `WorkItem`, представляющий рабочий элемент в бизнес\-процессе.  Подобно всем классам, он является производным от <xref:System.Object?displayProperty=fullName> и наследует все его методы.  В `WorkItem` имеется пять собственных членов.  Сюда входит конструктор, поскольку конструкторы не наследуются.  Класс `ChangeRequest` наследуется от `WorkItem` и представляет конкретный вид рабочего элемента.  `ChangeRequest` добавляет еще два члена к членам, унаследованным от `WorkItem` и <xref:System.Object>.  Он должен добавить собственный конструктор, и он также добавляет `originalItemID`.  Свойство `originalItemID` позволяет связать экземпляр `ChangeRequest` с исходным объектом `WorkItem`, к которому применен запрос на изменение.  
  
 ![Наследование классов](../../../csharp/programming-guide/classes-and-structs/media/class_inheritance.png "Class\_Inheritance")  
Наследование классов  
  
 В следующем рисунке показано, как выражаются в C\# отношения между классами, продемонстрированные в предыдущем примере.  В следующем примере также показано, как `WorkItem` переопределяет виртуальный метод <xref:System.Object.ToString%2A?displayProperty=fullName>, и как класс `ChangeRequest` наследует реализацию `WorkItem` метода.  
  
 [!CODE [csProgGuideInheritance#49](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideInheritance#49)]  
  
## Абстрактные и виртуальные методы  
 Когда базовый класс объявляет метод как [виртуальный](../../../csharp/language-reference/keywords/virtual.md), производный класс может [переопределить](../../../csharp/language-reference/keywords/override.md) метод с помощью своей собственной реализации.  Если базовый класс объявляет член как [абстрактный](../../../csharp/language-reference/keywords/abstract.md), то этот метод должен быть переопределен в любом неабстрактном классе, который прямо наследует от этого класса.  Если производный класс сам является абстрактным, то он наследует абстрактные члены, не реализуя их.  Абстрактные и виртуальные члены являются основой для полиморфизма, который является второй основной характеристикой объектно\-ориентированного программирования.  Дополнительные сведения см. в разделе [Полиморфизм](../../../csharp/programming-guide/classes-and-structs/polymorphism.md).  
  
## Абстрактные базовые классы  
 Можно объявить класс как [абстрактный](../../../csharp/language-reference/keywords/abstract.md), если необходимо предотвратить прямое создание экземпляров с помощью ключевого слова [new](../../../csharp/language-reference/keywords/new.md).  При таком подходе класс можно использовать, только если новый класс является производным от него.  Абстрактный класс может содержать один или несколько сигнатур методов, которые сами объявлены в качестве абстрактных.  Эти сигнатуры задают параметры и возвращают значение, но не имеют реализации \(тела метода\).  Абстрактному классу необязательно содержать абстрактные члены; однако, если класс все же содержит абстрактный член, то сам класс должен быть объявлен в качестве абстрактного.  Производные классы, которые сами не являются абстрактными, должны предоставить реализацию для любых абстрактных методов из абстрактного базового класса.  Дополнительные сведения см. в разделе [Абстрактные и запечатанные классы и члены классов](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md).  
  
## Интерфейсы  
 *интерфейс* является ссылочным типом, в чет\-то схожим с абстрактным базовым классом, который состоит только из абстрактных членов.  Когда класс реализует интерфейс, он должен предоставить реализацию для всех членов интерфейса.  В классе может быть реализовано несколько интерфейсов, хотя производным он может быть только от одного прямого базового класса.  
  
 Интерфейсы используются для определения определенных возможностей для классов, которые не обязательно имеют отношения тождественности.  Например, интерфейс <xref:System.IEquatable%601?displayProperty=fullName> может быть реализован любым классом или структурой, включающей клиентский код для определения эквивалентности двух объектов типа \(однако тип определяет эквивалентность\).  <xref:System.IEquatable%601> не подразумевает тот же вид отношений тождественности, который существует между базовым и производным классами \(например, `Mammal` является `Animal`\).  Дополнительные сведения см. в разделе [Интерфейсы](../../../csharp/programming-guide/interfaces/index.md).  
  
## Доступ производного класса к членам базового класса  
 Из производного класса можно получить доступ к открытым, защищенным, внутренним и защищенным внутренним членам базового класса.  Хотя производный класс и наследует закрытые члены базового класса, он не может получить доступ к этим членам.  Однако все эти закрытые члены все же присутствуют в производном классе и могут выполнять ту же работу, что и в самом базовом классе.  Например, предположим, что защищенный метод базового класса имеет доступ к закрытому полю.  Это поле должно присутствовать в производном классе для правильной работы унаследованного метода базового класса.  
  
## Предотвращение дальнейшего наследования  
 Класс может предотвратить наследование от него других классов или наследование от любых его членов, объявив себя или члены [запечатанными](../../../csharp/language-reference/keywords/sealed.md).  Дополнительные сведения см. в разделе [Абстрактные и запечатанные классы и члены классов](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md).  
  
## Скрытие производного класса членов базового класса  
 Производный класс может скрывать члены базового класса путем объявления членов с тем же именем и сигнатурой.  Модификатор [new](../../../csharp/language-reference/keywords/new.md) может использоваться, чтобы явно указать, что член не предназначен, чтобы быть переопределением базового члена.  Использование [new](../../../csharp/language-reference/keywords/new.md) не является обязательным, но при отсутствии использования [new](../../../csharp/language-reference/keywords/new.md) будет сгенерировано предупреждение компилятора.  Дополнительные сведения см. в разделах [Управление версиями с помощью ключевых слов Override и New](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md) и [Использование ключевых слов Override и New](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).  
  
## См. также  
 [Руководство по программированию на C\#](../../../csharp/programming-guide/index.md)   
 [Классы и структуры](../../../csharp/programming-guide/classes-and-structs/index.md)   
 [класс](../../../csharp/language-reference/keywords/class.md)   
 [struct](../../../csharp/language-reference/keywords/struct.md)