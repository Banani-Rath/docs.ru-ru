---
title: "Объекты (Руководство по программированию на C#) | Microsoft Docs"
ms.custom: ""
ms.date: "11/24/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-csharp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "объекты [C#], сведения об объектах"
  - "переменные [C#]"
ms.assetid: af4a5230-fbf3-4eea-95e1-8b883c2f845c
caps.latest.revision: 26
caps.handback.revision: 26
author: "BillWagner"
ms.author: "wiwagn"
manager: "wpickett"
translationtype: Human Translation
---
# Объекты (Руководство по программированию на C#)
[!INCLUDE[vs2017banner](../../../csharp/includes/vs2017banner.md)]

Определение класса или структуры подобно чертежу, на котором указаны действия, выполняемые типом.  В сущности, объект является блоком памяти, выделенной и настроенной в соответствии с чертежом.  Программа может создать множество объектов одного класса.  Объекты также называют экземплярами. Они могут храниться либо в именованной переменной, либо в массиве или коллекции.  Клиентский код — это код, использующий эти переменные для вызова методов и доступа к открытым свойствам объекта.  В объектно\-ориентированном языке, таком как C\#, стандартная программа состоит из нескольких динамически взаимодействующих объектов.  
  
> [!NOTE]
>  Поведение статических типов отличается от описанного здесь поведения.  Дополнительные сведения см. в разделе [Статические классы и члены статических классов](../../../csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members.md).  
  
## Экземпляры структур С. экземплярами класса  
 Поскольку классы являются ссылочными типами, в переменной объекта класса хранится ссылка на адрес объекта в управляемой куче.  Если первому объекту назначен второй объект того же типа, обе переменные ссылаются на объект, расположенный по данному адресу.  Эта особенность обсуждается более подробно далее в этом разделе.  
  
 Экземпляры классов создаются с помощью [оператора new](../../../csharp/language-reference/keywords/new-operator.md).  В следующем примере `Person` является типом, а `person1` и `person 2` — являются экземплярами или объектами этого типа.  
  
 [!CODE [csProgGuideStatements#30](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideStatements#30)]  
  
 Поскольку структуры являются типами значений, в переменной объекта структуры хранится копия всего объекта.  Экземпляры структур также можно создать с помощью оператора `new`, однако он не является обязательным, как показано в следующем примере.  
  
 [!CODE [csProgGuideStatements#31](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideStatements#31)]  
  
 Память для `p1` и `p2` выделена в стеке потока.  Эта память освобождена наряду с типом или методом, в котором она объявляется.  Эта одна причина того, почему структуры копируются при присваивании.  Напротив, при выходе всех ссылок на объект из области действия среда CLR выполняет автоматическое освобождение памяти \(сборку мусора\), выделенной для экземпляра класса.  Возможность детерминированного уничтожения объекта класса, имеющаяся в C\+\+, в данном случае отсутствует.  Дополнительные сведения о сборке мусора в [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)] см. в разделе [Garbage Collection](../Topic/Garbage%20Collection.md).  
  
> [!NOTE]
>  В среде CLR процесс выделения и освобождения памяти в управляемой куче значительно оптимизирован.  В большинстве случаев нет существенной разницы в затратах производительности на выделение экземпляра класса в куче и выделение экземпляра структуры в стеке.  
  
## Идентификатор объекта ДЛЯ. проверки равенства значений  
 Сравнивая два объекта на предмет равенства, сначала необходимо определить, нужно ли узнать, представляют ли две переменные один объект в памяти или значения одного или нескольких их полей являются равными.  Если планируется сравнить значения, следует решить, являются ли объекты экземплярами типов значений \(структурами\) или ссылочными типами \(классами, делегатами, массивами\).  
  
-   Чтобы определить, ссылаются ли два экземпляра класса на одно расположение в памяти \(это значит, что они имеют одинаковый *идентификатор*\), воспользуйтесь статическим методом <xref:System.Object.Equals%2A>.  \(<xref:System.Object?displayProperty=fullName> является неявным базовым классом для всех типов значений и ссылочных типов, включая структуры и классы, определенные пользователем\).  
  
-   Чтобы определить, имеют ли поля экземпляра в двух экземплярах структур одинаковые значения, воспользуйтесь методом <xref:System.ValueType.Equals%2A?displayProperty=fullName>.  Поскольку все структуры неявно наследуют от <xref:System.ValueType?displayProperty=fullName>, метод может быть вызван непосредственно в объекте, как показано в следующем примере.  
  
 [!CODE [csProgGuideStatements#32](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideStatements#32)]  
  
 Реализация <xref:System.ValueType?displayProperty=fullName> `Equals` использует отображение, поскольку необходимо определить поля, находящиеся в любой структуре.  При создании собственных структур переопределите метод `Equals` для предоставления эффективного алгоритма равенства, соответствующего вашему типу.  
  
-   Чтобы определить, равны ли значения полей в двух экземплярах класса, можно воспользоваться методом <xref:System.Object.Equals%2A> или [оператором \=\=](../../../csharp/language-reference/operators/equality-comparison-operator.md).  Однако их следует использовать, только если они переопределены или перегружены классом, чтобы предоставить пользовательское определение равенства для объектов этого типа.  Класс может также реализовывать интерфейс <xref:System.IEquatable%601>. или интерфейс <xref:System.Collections.Generic.IEqualityComparer%601>.  Оба интерфейса предоставляют методы, которые можно использовать для проверки равенства значений.  При создании собственных классов, переопределяющих `Equals`, следует выполнять инструкции из разделов [Практическое руководство. Определение равенства значений для типа](../../../csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md) и <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>.  
  
## Связанные разделы  
 Дополнительные сведения:  
  
-   [Классы](../../../csharp/programming-guide/classes-and-structs/classes.md)  
  
-   [Структуры](../../../csharp/programming-guide/classes-and-structs/structs.md)  
  
-   [Конструкторы](../../../csharp/programming-guide/classes-and-structs/constructors.md)  
  
-   [Деструкторы](../../../csharp/programming-guide/classes-and-structs/destructors.md)  
  
-   [События](../../../csharp/programming-guide/events/index.md)  
  
## См. также  
 [Руководство по программированию на C\#](../../../csharp/programming-guide/index.md)   
 [объект](../../../csharp/language-reference/keywords/object.md)   
 [Наследование](../../../csharp/programming-guide/classes-and-structs/inheritance.md)   
 [класс](../../../csharp/language-reference/keywords/class.md)   
 [struct](../../../csharp/language-reference/keywords/struct.md)   
 [Оператор new](../../../csharp/language-reference/keywords/new-operator.md)   
 [Система общих типов CTS](../../../standard/base-types/common-type-system.md)