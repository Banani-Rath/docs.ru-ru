---
title: "Ограничения параметров типа (Руководство по программированию на C#) | Microsoft Docs"
ms.custom: ""
ms.date: "11/24/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-csharp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "универсальные шаблоны [C#], ограничения типа"
  - "ограничения типа [C#]"
  - "параметры типа [C#], ограничения"
  - "параметр универсального типа [C#]"
ms.assetid: 141b003e-1ddb-4e1c-bcb2-e1c3870e6a51
caps.latest.revision: 41
caps.handback.revision: 41
author: "BillWagner"
ms.author: "wiwagn"
manager: "wpickett"
translationtype: Human Translation
---
# Ограничения параметров типа (Руководство по программированию на C#)
[!INCLUDE[vs2017banner](../../../csharp/includes/vs2017banner.md)]

При определении универсального типа можно ограничить виды типов, которые могут использоваться клиентским кодом в качестве аргументов типа при инициализации соответствующего класса.  При попытке клиентского кода создать экземпляр класса с помощью типа, который не допускается ограничением, в результате возникает ошибка компиляции.  Это называется ограничениями.  Ограничения определяются с помощью контекстно\-зависимого ключевого слова `where`.  В следующей таблице приведены шесть типов ограничений.  
  
|Ограничение|Описание|  
|-----------------|--------------|  
|where T: struct|Аргумент типа должен иметь тип значения.  Допускается указание любого типа значения, кроме <xref:System.Nullable>.  Дополнительные сведения см. в разделе [Использование допускающих значение NULL типов](../../../csharp/programming-guide/nullable-types/using-nullable-types.md).|  
|where T : class|Аргумент типа должен иметь ссылочный тип; это также распространяется на тип любого класса, интерфейса, делегата или массива.|  
|where T : new\(\)|Аргумент типа должен иметь открытый конструктор без параметров.  При использовании с другими ограничениями ограничение `new()` должно устанавливаться последним.|  
|where T : \<base class name\>|Аргумент типа должен являться или быть производным от указанного базового класса.|  
|where T : \<interface name\>|Аргумент типа должен являться или реализовывать указанный интерфейс.  Можно установить несколько ограничений интерфейса.  Ограничивающий интерфейс также может быть универсальным.|  
|where T : U|Аргумент типа, предоставляемый в качестве T, должен совпадать с аргументом, предоставляемым в качестве U, или быть производным от него.|  
  
## Применение ограничений  
 При необходимости проверить какой\-либо элемент универсального списка, чтобы определить, является ли он допустимым, или сравнить его с другим элементом, компилятор должен иметь гарантию, что оператор или вызываемый им метод будет поддерживаться любым аргументом типа, который может определяться клиентским кодом.  Такая гарантия обеспечивается применением одного или более ограничений к определению универсального класса.  Например, ограничение базового класса сообщает компилятору, что в качестве аргументов типа будут использоваться только объекты определенного типа или являющиеся производными от этого типа.  Получив такую гарантию, компилятор может разрешить вызов методов этого типа в универсальном классе.  Ограничения накладываются с помощью контекстно\-зависимого ключевого слова `where`.  В следующем примере кода показаны функции, которые можно добавить к классу `GenericList<T>` \(в разделе [Введение в универсальные шаблоны](../../../csharp/programming-guide/generics/introduction-to-generics.md)\) путем применения ограничения базового класса.  
  
 [!CODE [csProgGuideGenerics#11](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideGenerics#11)]  
  
 Это ограничение позволяет универсальному классу использовать свойство `Employee.Name`, потому что все элементы типа T гарантированно являются объектом `Employee` или объектом, наследующим от `Employee`.  
  
 К одному параметру типа может применяться несколько ограничений, при этом сами ограничения могут быть универсального типа, как показано ниже.  
  
 [!CODE [csProgGuideGenerics#12](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideGenerics#12)]  
  
 При наложении ограничений на параметр типа увеличивается число допустимых операций и вызовов методов, поддерживаемых ограничивающим типом и всеми типами в его иерархии наследования.  Поэтому при разработке универсальных классов или методов, в случае выполнения какой\-либо операции с универсальными членами помимо простого назначения или в случае вызова каких\-либо методов, не поддерживаемых объектом `System.Object`, необходимо будет применить ограничения к параметру типа.  
  
 В случае применения ограничения `where T : class` следует избегать использования операторов `==` и `!=` с параметром типа, потому что эти операторы выполняют только проверку удостоверения ссылки, но не проверяют равенство величины.  Это верно даже в том случае, если эти операторы перегружаются в тип, который используется в качестве аргумента.  В следующим коде иллюстрируется эта особенность; выдается результат false, несмотря на то что класс <xref:System.String> используется для перегрузки оператора `==`.  
  
 [!CODE [csProgGuideGenerics#13](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideGenerics#13)]  
  
 Причиной такого поведения является то, что во время компиляции компилятор знает только, что T является ссылочным типом, и поэтому должен использовать операторы по умолчанию, которые действительны для всех ссылочных типов.  Если необходимо проверить равенство значения, рекомендуется также применить ограничение `where T : IComparable<T>` и реализовать этот интерфейс в любом классе, который используется для создания универсального класса.  
  
## Ограничение нескольких параметров  
 Ограничение может применяться к нескольким параметрам, а несколько ограничений — к одному параметру, как показано в следующем примере:  
  
 [!CODE [csProgGuideGenerics#64](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideGenerics#64)]  
  
## Неограниченные параметры типа  
 Параметры типа, не имеющие ограничений, например T в открытом классе `SampleClass<T>{}`, называются неограниченными параметрами типа.  Неограниченные параметры типа подчиняются следующим правилам.  
  
-   Операторы `!=` и `==` не могут использоваться из\-за отсутствия гарантии того, что конкретный аргумент типа будет поддерживать эти операторы.  
  
-   Их можно преобразовывать в и из объекта `System.Object` или явно преобразовывать в любой тип интерфейса.  
  
-   Допускается сравнение со значением [NULL](../../../csharp/language-reference/keywords/null.md).  При сравнении неограниченного параметра со значением `null` сравнение всегда возвращает результат false, если аргумент типа является типом значения.  
  
## Параметры типа как ограничения  
 Использование параметра универсального типа в качестве ограничителя полезно, если функция\-член с собственным параметром типа должна ограничивать этот параметр параметром содержащего типа, как показано в следующем примере.  
  
 [!CODE [csProgGuideGenerics#14](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideGenerics#14)]  
  
 В предыдущем примере `T` является ограничением типа в контексте метода `Add` и неограниченным параметром типа в контексте класса `List`.  
  
 Параметры типа также могут использоваться как ограничители в определениях общих классов.  Обратите внимание, что ограничение типа должно объявляться в угловых скобках вместе со всеми другими параметрами типа.  
  
 [!CODE [csProgGuideGenerics#15](../CodeSnippet/VS_Snippets_VBCSharp/csProgGuideGenerics#15)]  
  
 Применение параметров типа с универсальными классами очень ограничено, потому что компилятор может в отношении параметра типа допускать только, что он является производным от `System.Object`.  Параметры типа следует использовать как ограничения для универсальных классов в ситуациях, когда требуется обеспечить отношение наследования между двумя параметрами типа.  
  
## См. также  
 <xref:System.Collections.Generic>   
 [Руководство по программированию на C\#](../../../csharp/programming-guide/index.md)   
 [Введение в универсальные шаблоны](../../../csharp/programming-guide/generics/introduction-to-generics.md)   
 [Универсальные классы](../../../csharp/programming-guide/generics/generic-classes.md)   
 [Ограничение new](../../../csharp/language-reference/keywords/new-constraint.md)