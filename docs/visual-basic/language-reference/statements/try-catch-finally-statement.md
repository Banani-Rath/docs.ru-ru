---
title: "Оператор Try... Catch... Finally (Visual Basic) | Microsoft Docs"
ms.custom: ""
ms.date: "11/24/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-visual-basic"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vb.Try...Catch...Finally"
  - "vb.when"
  - "vb.Finally"
  - "vb.Catch"
  - "vb.Try"
dev_langs: 
  - "VB"
helpviewer_keywords: 
  - "Catch - оператор"
  - "обработка ошибок, код в процессе выполнения"
  - "Finally - ключевое слово [Visual Basic], Try...Catch...Finally"
  - "структурированная обработка исключений, Try...Catch...Finally - операторы"
  - "Try - оператор"
  - "Try - оператор, Try...Catch...Finally"
  - "Try...Catch...Finally - операторы"
  - "обработка исключений try-catch, Try...Catch...Finally - операторы"
  - "код Visual Basic, обработка ошибок во время выполнения"
  - "When - ключевое слово"
ms.assetid: d6488026-ccb3-42b8-a810-0d97b9d6472b
caps.latest.revision: 69
caps.handback.revision: 69
author: "stevehoag"
ms.author: "shoag"
manager: "wpickett"
translationtype: Human Translation
---
# Оператор Try... Catch... Finally (Visual Basic)
[!INCLUDE[vs2017banner](../../../csharp/includes/vs2017banner.md)]

Позволяет, не прерывая выполнение программы, обрабатывать некоторые или все возможные ошибки, которые могут возникать в конкретном блоке кода.  
  
## Синтаксис  
  
```  
Try  
    [ tryStatements ]  
    [ Exit Try ]  
[ Catch [ exception [ As type ] ] [ When expression ]  
    [ catchStatements ]  
    [ Exit Try ] ]  
[ Catch ... ]  
[ Finally  
    [ finallyStatements ] ]  
End Try  
```  
  
## Части  
  
|||  
|-|-|  
|Термин|Определение|  
|`tryStatements`|Необязательный параметр.  Один или несколько операторов, в которых может возникнуть ошибка.  Могут быть составными операторами.|  
|`Catch`|Необязательный параметр.  Разрешено использование нескольких блоков `Catch`.  Если исключение возникает при обработке блока `Try`, то каждая инструкция `Catch` сравнивается в текстовом порядке, чтобы определить обрабатывает ли она это исключение, с `exception`, представляющим исключение, которое возникло.|  
|`exception`|Необязательный параметр.  Любое имя переменной.  Значение `exception` является значением возникшей ошибки.  Используется оператором `Catch` для задания перехватываемой ошибки.  Если аргумент опущен, инструкция `Catch` перехватывает все исключения.|  
|`type`|Необязательный параметр.  Указывает тип класса фильтра.  Если значение `exception` относится к типу, указанному параметром `type`, или к типу, производному от него, данный идентификатор становится привязкой к объекту исключения.|  
|`When`|Необязательный параметр.  Инструкция `Catch` с предложением `When` перехватывает исключения, только если результат вычисления `expression` равен `True`.  Предложение `When` используется только после проверки типа исключения, и `expression` может ссылаться на идентификатор, представляющий исключение.|  
|`expression`|Необязательный параметр.  Должен однозначно приводиться к типу `Boolean`.  Любое выражение, которое описывает универсальный фильтр.  Обычно используется для фильтрации по номеру ошибки.  Используется с зарезервированным словом `When` для определения условий, при которых будет перехватываться данная ошибка.|  
|`catchStatements`|Необязательный параметр.  Операторы обработки ошибок, возникших в соответствующем блоке `Try`.  Могут быть составными операторами.|  
|`Exit Try`|Необязательный параметр.  Зарезервированное слово, которое разбивает структуру `Try...Catch...Finally`.  Выполнение возобновляется с кода, непосредственно следующего за оператором `End Try`.  Инструкция `Finally` будет по\-прежнему выполняться.  Не допускается в блоках `Finally`.|  
|`Finally`|Необязательный параметр.  Блок `Finally` всегда выполняется по окончании выполнения любой части оператора `Try...Catch`.|  
|`finallyStatements`|Необязательный параметр.  Операторы, выполняемые после выполнения всех остальных действий по обработке ошибки.|  
|`End Try`|Завершает структуру `Try...Catch...Finally`.|  
  
## Заметки  
 Если предполагается, что во время выполнения определенного раздела кода может возникнуть определенное исключение, то поместите код в блок `Try` и используйте блок `Catch` для сохранения управления и обработки возникшего исключения.  
  
 Оператор try\-catch `Try…Catch` состоит из блока `Try`, за которым следует одно или несколько предложений `Catch`, в которых определяются обработчики для различных исключений.  Когда текущее исключение выбрасывается в блоке `Try`, [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] ищет оператор `Catch`, обрабатывающий исключение.  Если не найден соответствующий оператор `Catch`, [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] рассматривается метод, который вызвал текущий метод, и так далее вверх по стеку вызовов.  Если блок `Catch` не найден, то среда [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] отображает пользователю сообщение о необработанном исключении и останавливает выполнение программы.  
  
 Можно использовать более одного оператора `Catch` в операторе `Try…Catch`.  В этом случае будет иметь значение порядок следования предложений `Catch`, поскольку предложения будут проверяться именно в этом порядке.  Более общие исключения следует перехватывать после более частных.  
  
 Следующие условные операторы `Catch` являются наименее конкретными и будет перехватывать все исключения, производные от класса <xref:System.Exception>.  Как правило, следует использовать один из этих вариантов в качестве последнего блока `Catch` структуры `Try...Catch...Finally` после перехвата всех ожидаемых конкретных исключений.  Поток управления никогда не достигает блока `Catch`, который следует за любым из этих вариантов.  
  
-   `type` имеет значение `Exception`, например `Catch ex As Exception`.  
  
-   Оператор не имеет переменной `exception`, например `Catch`.  
  
 Когда оператор `Try…Catch…Finally` вложен в другой блок `Try` , [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] сначала проверяет каждый оператор `Catch`  во внутреннем блоке `Try` .  Если соответствующий оператор `Catch` не найден, поиск продолжается в операторах `Catch` внешнего блока `Try…Catch…Finally`.  
  
 Локальные переменные блока `Try` недоступны в блоке `Catch`, поскольку это отдельные блоки.  Если нужно использовать переменную в нескольких блоках, то следует объявить ее вне структуры `Try...Catch...Finally`.  
  
> [!TIP]
>  Оператор `Try…Catch…Finally` доступен также в качестве фрагмента кода IntelliSense.  В Диспетчере фрагментов кода, разверните **Шаблоны кода \- If, For Each, Try Catch, Property, и т.д.**и затем **Обработка ошибок \(исключения\)** .  Дополнительные сведения см. в разделе [Фрагменты кода](/visual-studio/ide/code-snippets).  
  
## Блок finally  
 Если имеется одна или несколько инструкций, которые необходимо запустить до выхода из структуры `Try`, используйте блок `Finally`.  Элемент управления передает в блок `Finally` только перед передачей из структуры `Try…Catch`.  Это справедливо даже в том случае, если исключение возникает внутри структуры `Try`.  
  
 `Finally` Блок является полезным для запуска любой код, который должен выполняться, даже если есть исключение.  Управление всегда передается блоку `Finally` независимо от того, как была выполнен выход из блока `Try...Catch`.  
  
 Код в блоке `Finally` выполняется, даже если ваш код встречает оператор `Return` в блоке `Try` или `Catch`.  Элемент управления не передает из блока `Try` или блока `Catch` в соответствующий блок `Finally` в следующих случаях:  
  
-   [Оператор End](../../../visual-basic/language-reference/statements/end-statement.md) обнаруживается внутри блока`Try` или `Catch`.  
  
-   <xref:System.StackOverflowException> создается внутри блока `Try` или `Catch`.  
  
 Он является недопустимым явного для получения выполнения в блоке `Finally`.  Переключиться из блока выполнение `Finally` является недопустимым, за исключением через исключения.  
  
 Если инструкция `Try` не содержит ни одного блока `Catch`, то она должна содержать `Finally`.  
  
> [!TIP]
>  Если не требуется перехватывать определенные исключения, оператор `Using` действует аналогично блоку `Try…Finally` и гарантирует освобождение ресурсов независимо от способа выхода из блока.  Это справедливо даже в случае необработанного исключения.  Дополнительные сведения см. в разделе [Оператор Using](../../../visual-basic/language-reference/statements/using-statement.md).  
  
## Аргументы исключения  
 `Catch` блокирует аргумент `exception`, который представляет собой экземпляр класса <xref:System.Exception> или класса, производного от класса `Exception`.  Экземпляр класса `Exception` соответствует возникшей в блоке `Try` ошибке.  
  
 Свойства объекта `Exception` помогают в определении причины и места возникновения исключений.  Например, свойство <xref:System.Exception.StackTrace%2A> содержит список вызванных методов, которые привели к исключению, помогая обнаружить место возникновения ошибки в коде.  <xref:System.Exception.Message%2A> возвращает сообщение, описывающее исключение.  <xref:System.Exception.HelpLink%2A> возвращает ссылку на связанный файл справки.  <xref:System.Exception.InnerException%2A> возвращает объект`Exception` , который вызвал текущее исключение, или оно возвращает `Nothing`, если нет никакой первоначальной `Exception`.  
  
## Соображения при использовании оператора Try…Catch  
 Используйте оператор `Try…Catch` только для сигнала о необычных или непредвиденных событиях программы.  Это связано со следующими причинами:  
  
-   Перехват исключений во время выполнения создает дополнительные накладные расходы и может быть медленнее, чем предварительная проверка чтобы избежать исключений.  
  
-   Если блок `Catch`  не обрабатывается правильно, исключение может не сообщаться правильно для пользователей.  
  
-   Обработка исключений делает программы более сложным.  
  
 Не всегда требуется оператор `Try…Catch`  для проверки возможного условия.  В следующем примере проверяется, существует ли файл перед попыткой открыть его.  Это уменьшает потребность перехвата исключения, созданного методом <xref:System.IO.File.OpenText%2A>.  
  
 [!CODE [VbVbalrStatements#94](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrStatements#94)]  
  
 Убедитесь, что код в блоках `Catch` может надлежащим образом сообщить исключения для пользователей, через журналирование, безопасное с точки зрения потоков, или соответствующие сообщения.  В противном случае исключения могут остаться незамеченными.  
  
## Методы Async  
 Если пометить метод с модификатором [Async](../../../visual-basic/language-reference/modifiers/async.md), можно использовать оператор [подождите](../../../visual-basic/language-reference/operators/await-operator.md) в методе.  Выписка с оператором `Await` приостанавливает выполнение методов до тех пор, пока подожданная задача не завершится.  Задача представляет текущие работы.  Задача, которая связана с оператором `Await` завершает выполнение возобновляется в одном методе.  Дополнительные сведения см. в разделе [Поток управления в асинхронных программах](../Topic/Control%20Flow%20in%20Async%20Programs%20\(C%23%20and%20Visual%20Basic\).md).  
  
 Задача, возвращаемая методом Async может быть выполнен в состоянии сбоя, что указывает на то, что она была завершена из\-за необработанного исключения.  Задача также может завершиться в отмененном состоянии, которое приводит к тому, `OperationCanceledException` возникающем из выражения ожидания.  Для перехвата любой тип исключения, поместите выражения `Await`, связанный с задачей в блоке `Try` и перехватывать исключения в блоке `Catch`.  Пример приведен ниже.  
  
 Задача может находиться в состоянии сбоя, так как несколько исключений, ответственные за его ошибаться.  Например, задача может быть результатом вызова метода <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=fullName>.  Если ожидается такой задачи, обнаружено исключение только одно из исключений, и невозможно предсказать, перехватывается исключение будет.  Пример приведен ниже.  
  
 Выражение не может быть `Await` внутри блока `Catch` или блока `Finally`.  
  
## Итераторы  
 Функция итератора или метод доступа `Get` выполняет пользовательскую итерацию по коллекции.  Итератор выписку [Выходные данные](../../../visual-basic/language-reference/statements/yield-statement.md) используется для возвращения каждый элемент коллекции одной записи за раз.  Вызовите функцию итератора с помощью [Оператор For Each...Next](../../../visual-basic/language-reference/statements/for-each-next-statement.md).  
  
 Оператор `Yield` может быть внутри блока `Try`.  Блок `Try`, содержащий выписку `Yield` может содержать блоки `Catch` и может содержать блок `Finally`.  Блоки try см. в разделе Visual Basic" [Итераторы](../Topic/Iterators%20\(C%23%20and%20Visual%20Basic\).md) для примера.  
  
 Оператор `Yield` не может быть `Catch` блока или внутри блока `Finally`.  
  
 Если тело `For Each` \(за пределами функции итератора\) создает исключение, оно не выполняется `Catch` в блок функции итератора, но выполняется в блок `Finally` функции итератора.  Блок `Catch` внутри функции итератора перехватывает только исключения, происходящие внутри функции итератора.  
  
## Ситуации с частичным доверием  
 В случаях частичного доверия, например, в приложении, размещенном в сетевом ресурсе, `Try...Catch...Finally` не перехватит исключения системы безопасности, возникающие перед обращением к методу, содержащему вызов.  В следующем примере, если поместить его на общем ресурсе сервера и запустить оттуда, то возникнет ошибка « System.Security.SecurityException: Request Failed." Дополнительные сведения о ошибках безопасности см. в описании класса <xref:System.Security.SecurityException>.  
  
 [!CODE [VbVbalrStatements#85](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrStatements#85)]  
  
 В таких случаях частичного доверия необходимо поместить инструкцию `Process.Start` в отдельную `Sub`.  Начальный вызов `Sub` не удастся.  Это позволяет `Try...Catch` перехватить вызов перед началом выполнения `Sub`, которая содержит `Process.Start`, и создаст исключение безопасности.  
  
## Пример  
 В следующем примере показано структура оператора `Try...Catch...Finally`.  
  
 [!CODE [VbVbalrStatements#86](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrStatements#86)]  
  
## Пример  
 В следующем примере метод `CreateException` вызывает `NullReferenceException`.  Код, создающий исключение, не входит в блок `Try`.  Поэтому метод `CreateException` не обрабатывает исключение.  Метод `RunSample`  обрабатывает исключение, поскольку вызов метода `CreateException`  находится в блоке `Try`.  
  
 Пример включает операторы `Catch`  для нескольких типов исключений, отсортированные от наиболее конкретных к наиболее общим.  
  
 [!CODE [VbVbalrStatements#91](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrStatements#91)]  
  
## Пример  
 Следующий пример показывает, как использовать оператор `Catch When` для фильтрации в условном выражении.  Если при вычислении условного выражения получено значение `True`, выполняется код в блоке `Catch` .  
  
 [!CODE [VbVbalrStatements#92](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrStatements#92)]  
  
## Пример  
 В следующем примере есть оператор `Try…Catch` , который содержится в блоке `Try` .  Внутренний блок `Catch` выдает исключение, у которого для свойства `InnerException` задано исходное исключение.  Внешний блок `Catch` сообщает свои собственные исключения и внутреннее исключение.  
  
 [!CODE [VbVbalrStatements#93](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrStatements#93)]  
  
## Пример  
 Следующий пример иллюстрирует обработку ошибок для асинхронных методов.  Для перехвата исключения, которое применяется к задаче async выражение `Await` в блоке `Try` вызывающей стороны, и исключение перехватывается в блоке `Catch`.  
  
 Раскомментируйте линия `Throw New Exception` в примере для демонстрации обработку ошибок.  Исключение перехватывается в блоке `Catch`, свойство `IsFaulted` задачи устанавливается в `True`, а свойство `Exception.InnerException` задачи устанавливается на исключение.  
  
 Раскомментируйте линия `Throw New OperationCancelledException` для демонстрации того, что происходит при отмене асинхронный процесс.  Исключение перехватывается в блоке `Catch`, а свойство `IsCanceled` задачи устанавливается в `True`.  Однако при определенных условиях, которые не применяются к данному примеру `IsFaulted` установлено в `True` и `IsCanceled` установлено в `False`.  
  
 [!CODE [csAsyncExceptions#1](../CodeSnippet/VS_Snippets_VBCSharp/csasyncexceptions#1)]  
  
## Пример  
 Следующий пример иллюстрирует обработку исключений, где несколько задач могут привести к появлению нескольких исключении.  Блок `Try` содержит выражение `Await` для задачи, которую <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=fullName> возвращен.  Задача завершена, когда 3 задачи, к которой применяется <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=fullName>.  
  
 Каждая из задач 3 причин исключения.  Блок `Catch` перебирает исключения, которые находятся в свойстве `Exception.InnerExceptions` задачи, которую `Task.WhenAll` возвращен.  
  
 [!CODE [csAsyncExceptions#3](../CodeSnippet/VS_Snippets_VBCSharp/csasyncexceptions#3)]  
  
## См. также  
 <xref:Microsoft.VisualBasic.Information.Err%2A>   
 <xref:System.Exception>   
 [Оператор Exit](../../../visual-basic/language-reference/statements/exit-statement.md)   
 [Оператор On Error](../../../visual-basic/language-reference/statements/on-error-statement.md)   
 [Рекомендации по использованию фрагментов кода](/visual-studio/ide/best-practices-for-using-code-snippets)   
 [Обработка исключений](../Topic/Exception%20Handling%20\(Task%20Parallel%20Library\).md)   
 [Оператор Throw](../../../visual-basic/language-reference/statements/throw-statement.md)