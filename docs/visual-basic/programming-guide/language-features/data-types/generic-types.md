---
title: "Универсальные типы в Visual Basic (Visual Basic) | Microsoft Docs"
ms.custom: ""
ms.date: "11/24/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-visual-basic"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
helpviewer_keywords: 
  - "универсальные интерфейсы"
  - "аргументы типа данных, определение"
  - "универсальные делегаты"
  - "аргументы [Visual Basic], типы данных"
  - "ключевого слова, использование"
  - "делегаты, универсальные"
  - "ограничения, универсальные типы в Visual Basic"
  - "универсальные параметры"
  - "параметры типа данных"
  - "процедуры, универсальные "
  - "универсальные процедуры"
  - "типы данных [Visual Basic], универсальные"
  - "типы данных [Visual Basic], в качестве параметров"
  - "универсальные шаблоны Visual Basic, универсальные типы"
  - "типы данных [Visual Basic], в качестве аргументов"
  - "универсальные классы, Visual Basic"
  - "параметры, типы"
  - "аргументы типа"
  - "интерфейсы, универсальные"
  - "универсальные шаблоны [Visual Basic]"
  - "типы [Visual Basic], универсальные"
  - "параметры, универсальные"
  - "универсальные структуры"
  - "универсальные классы"
  - "параметры типа"
  - "аргументы типа данных"
  - "структуры, универсальные"
  - "параметры, тип данных"
  - "коллекции, универсальные"
  - "классы [Visual Basic], универсальные"
  - "параметры типа данных, определение"
  - "аргументы типа, определение"
  - "аргументы [Visual Basic], тип"
ms.assetid: 89f771d9-ecbb-4737-88b8-116b63c6cf4d
caps.latest.revision: 45
caps.handback.revision: 45
author: "stevehoag"
ms.author: "shoag"
manager: "wpickett"
translationtype: Human Translation
---
# Универсальные типы в Visual Basic (Visual Basic)
[!INCLUDE[vs2017banner](../../../../csharp/includes/vs2017banner.md)]

*Универсальный тип* является одиночным элементом программирования, который используется для выполнения одинаковой функциональности для различных типов данных. При определении универсальных классов или процедур не нужно определять отдельную версию для каждого типа данных, для которых может потребоваться выполнение этой функциональности.  
  
 В качестве аналогии можно привести отвертку со съемными головками. Вы смотрите на шуруп, который нужно завинтить, и выбираете подходящую головку \(шлицевую, крестовую или звездообразную\). Меняя головки, вы выполняете с помощью отвертки одну и ту же функцию: завинчиваете или вывинчиваете шуруп.  
  
 ![Схема отвертки, используемой в качестве универсального средства](../../../../visual-basic/programming-guide/language-features/data-types/media/genericscrewdriver.gif "GenericScrewDriver")  
Набор отверток в качестве универсального средства  
  
 При определении универсального типа его можно параметризовать с помощью одного или нескольких типов данных. Это позволяет использовать код, чтобы адаптировать типы данных к его требованиям. В коде можно объявить несколько различных элементов программирования из универсального элемента, каждый из которых действует для разных наборов типов данных. Но все объявленные элементы подчиняются одинаковой логике, независимо от того, какие типы данных они используют.  
  
 Допустим, вам нужно создать и использовать класс очереди, который работает с определенным типом данных, например `String`. Можно объявить такой класс из <xref:System.Collections.Generic.Queue%601?displayProperty=fullName>, как показано в следующем примере.  
  
 [!CODE [VbVbalrDataTypes#1](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrDataTypes#1)]  
  
 Теперь можно использовать `stringQ` для работы исключительно со значениями `String`. Так как `stringQ` предназначен конкретно для `String`, а не является универсальным для значений `Object`, вам не потребуется позднее связывание или преобразование типа. Это экономит время выполнения и сокращает число ошибок во время выполнения.  
  
 Дополнительные сведения об использовании универсального типа см. в разделе [Практическое руководство. Использование универсального класса](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md).  
  
## Пример универсального класса  
 В следующем примере показано определение каркаса универсального класса.  
  
 [!CODE [VbVbalrDataTypes#2](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrDataTypes#2)]  
  
 В предыдущем каркасе `t` — это *параметр типа*, то есть заполнитель для типа данных, указанного при объявлении класса. В другом месте в коде можно объявлять различные версии `classHolder`, указав различные типы данных для `t`. Два таких объявления показаны в следующем примере.  
  
 [!CODE [VbVbalrDataTypes#3](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrDataTypes#3)]  
  
 Предыдущие инструкции объявляют *сконструированные классы*, в которых указанный тип заменяет параметр типа. Эта замена распространяется по всему коду сконструированного класса. В следующем примере показано, как процедура `processNewItem` выглядит в `integerClass`.  
  
 [!CODE [VbVbalrDataTypes#4](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrDataTypes#4)]  
  
 Более полный пример содержится в разделе [Практическое руководство. Определение класса, реализующего одинаковую функциональность для различных типов данных](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md).  
  
## Допустимые элементы программирования  
 Можно определять и использовать универсальные классы, структуры, интерфейсы, процедуры и делегаты. Обратите внимание, что [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] определяет несколько универсальных классов, структур и интерфейсов, которые представляют собой часто используемые универсальные элементы. Пространство имен <xref:System.Collections.Generic?displayProperty=fullName> предоставляет словари, списки, очереди и стеки. Перед определением собственного универсального элемента посмотрите, не существует ли он уже в <xref:System.Collections.Generic?displayProperty=fullName>.  
  
 Процедуры не являются типами, но можно определять и использовать универсальные процедуры. См. раздел [Универсальные процедуры в Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/generic-procedures.md).  
  
## Преимущества универсальных типов  
 Универсальный тип служит в качестве основы для объявления нескольких различных программных элементов, каждый из которых работает с определенным типом данных. Альтернативы для универсального типа:  
  
1.  одиночный тип, работающий с типом данных `Object`.  
  
2.  Набор *типозависимых* версий типа; каждая версия кодируется индивидуально и работает с одним конкретным типом данных \(например `String`, `Integer`\) или с определяемым пользователем типом, например `customer`.  
  
 Универсальный тип имеет следующие преимущества по сравнению с этими альтернативами.  
  
-   **Безопасность.** Универсальные типы обеспечивают проверку типов во время компиляции. Типы на основе `Object` принимают любой тип данных, и необходимо написать код, чтобы проверить, является ли тип входных данных приемлемым. При использовании универсальных типов компилятор может перехватить несоответствие типов до выполнения.  
  
-   **Производительность.** Универсальные типы не должны *упаковывать* и *распаковывать* данные, так как каждый из них является специальным для одного типа данных. Операции, основанные на `Object`, должны упаковывать типы входных данных для их преобразования в `Object` и распаковать данные, предназначенные для вывода. Упаковка и распаковка снижают производительность.  
  
     Типы на основе `Object` имеют позднее связывание, а значит, для доступа к их элементам требуется дополнительный код во время выполнения. Это также снижает производительность.  
  
-   **Консолидация кода.** Код в универсальном типе должен быть определен только один раз. Набор типозависимых версий типа должен реплицировать тот же код в каждой версии. Единственное отличие состоит в конкретном типе данных для этой версии. При использовании универсальных типов типозависимые версии формируются из исходного универсального типа.  
  
-   **Повторное использование кода.** Код, который не зависит от определенного типа данных, можно повторно использовать с различными типами данных, если он является универсальным. Часто его можно повторно использовать даже с типом данных, который изначально не предусматривался.  
  
-   **Поддержка IDE.** При использовании сконструированного типа, объявленного из универсального типа, интегрированная среда разработки \(IDE\) может предоставить дополнительную поддержку при разработке кода. Например, IntelliSense может показать типозависимые параметры аргумента для конструктора или метода.  
  
-   **Универсальные алгоритмы.** Абстрактные алгоритмы, которые не зависят от типов, хорошо подходят для универсальных типов. Например, универсальную процедуру, которая сортирует элементы с помощью интерфейса <xref:System.IComparable>, можно использовать с любым типом данных, который реализует <xref:System.IComparable>.  
  
## Ограничения  
 Несмотря на то, что код в определении универсального типа должен быть максимально независимым от типов, может потребоваться определенная возможность любого типа данных, указанного для универсального типа. Например, если необходимо сравнить два элемента с целью сортировки или упорядочивания, их тип данных должен реализовывать интерфейс <xref:System.IComparable>. Соблюдение этого требования можно обеспечить путем добавления *ограничения* к параметру типа.  
  
### Пример ограничения  
 В следующем примере показано каркасное определение класса с ограничением, которое требует аргумент типа для реализации <xref:System.IComparable>.  
  
 [!CODE [VbVbalrDataTypes#5](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrDataTypes#5)]  
  
 Если последующий код попытается создать класс из `itemManager`, используя тип, который не реализует <xref:System.IComparable>, компилятор сообщит об ошибке.  
  
### Типы ограничений  
 Ограничение может содержать приведенные ниже требования в любой комбинации.  
  
-   Аргумент типа должен реализовывать один или несколько интерфейсов  
  
-   Аргумент типа должен наследовать только из одного класса или быть типом только одного класса.  
  
-   Аргумент типа должен предоставлять конструктор без параметров, доступный коду, который создает объекты из него.  
  
-   Аргумент типа должен быть *типом ссылки* или *типом значения*.  
  
 Если нужно задать более одного требования, используйте разделенный запятыми *список ограничений*, заключенный в фигурные скобки \(`{ }`\). Чтобы требовать доступный конструктор, включите в список ключевое слово [Оператор New](../../../../visual-basic/language-reference/operators/new-operator.md). Чтобы требовать ссылочный тип, включите ключевое слово `Class`. Чтобы требовать тип значения, включите ключевое слово `Structure`.  
  
 Дополнительные сведения об ограничениях см. в разделе [Список типов](../../../../visual-basic/language-reference/statements/type-list.md).  
  
### Пример множественных ограничений  
 В следующем примере показано каркасное определение универсального класса со списком ограничений в параметре типа. В коде, который создает экземпляр этого класса, аргумент типа должен реализовывать интерфейсы <xref:System.IComparable> и <xref:System.IDisposable>, быть ссылочным типом и предоставлять доступ к конструктору без параметров.  
  
 [!CODE [VbVbalrDataTypes#6](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrDataTypes#6)]  
  
## Важные термины  
 Универсальные типы вводят и используют следующие термины.  
  
-   *Универсальный тип*. Определение класса, структуры, интерфейса, процедуры или делегата, для которого необходимо указать по крайней мере один тип данных при объявлении.  
  
-   *Параметр типа*. В определении универсального типа это заполнитель для типа данных, указываемый при объявлении типа.  
  
-   *Аргумент типа*. Определенный тип данных, который заменяет параметр типа при объявлении сконструированного типа из универсального типа.  
  
-   *Ограничение*. Условие для параметра типа, ограничивающее аргумент типа, который можно указать для него. Ограничение может требовать, чтобы аргумент типа реализовывал определенный интерфейс, был определенным классом или наследовал от него, имел доступный конструктор без параметров или был ссылочным типом или типом значения. Можно объединять эти ограничения, но невозможно указывать более одного класса.  
  
-   *Сконструированный тип*. Класс, структура, интерфейс, процедура или делегат, объявленный из универсального типа с помощью указания аргументов типа для параметров типа.  
  
## См. также  
 [Типы данных](../../../../visual-basic/programming-guide/language-features/data-types/index.md)   
 [Символы типов](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)   
 [Типы значений и ссылочные типы](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)   
 [Преобразование типов в Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)   
 [Устранение неполадок, связанных с типами данных](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)   
 [Типы данных](../../../../visual-basic/language-reference/data-types/data-type-summary.md)   
 [Of](../../../../visual-basic/language-reference/statements/of-clause.md)   
 [As](../../../../visual-basic/language-reference/statements/as-clause.md)   
 [Тип данных Object](../../../../visual-basic/language-reference/data-types/object-data-type.md)   
 [Ковариация и контрвариация](../Topic/Covariance%20and%20Contravariance%20\(C%23%20and%20Visual%20Basic\).md)   
 [Итераторы](../Topic/Iterators%20\(C%23%20and%20Visual%20Basic\).md)