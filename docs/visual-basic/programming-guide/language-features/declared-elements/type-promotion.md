---
title: "Повышение типа (Visual Basic) | Microsoft Docs"
ms.custom: ""
ms.date: "11/24/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-visual-basic"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
helpviewer_keywords: 
  - "объявленные элементы, область действия"
  - "объявленные элементы, видимость"
  - "Partial - ключевое слово, неожиданные результаты с повышением типа"
  - "область действия, объявленные элементы"
  - "область действия, Visual Basic"
  - "повышение типа"
  - "видимость, объявленные элементы"
ms.assetid: 035eeb15-e4c5-4288-ab3c-6bd5d22f7051
caps.latest.revision: 17
caps.handback.revision: 17
author: "stevehoag"
ms.author: "shoag"
manager: "wpickett"
translationtype: Human Translation
---
# Повышение типа (Visual Basic)
[!INCLUDE[vs2017banner](../../../../csharp/includes/vs2017banner.md)]

Когда в модуле объявляется элемент программирования, [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] повышает уровень его области до пространства имен, содержащего модуль.  Это называется *повышение типа*.  
  
 В приведенном ниже примере показано определение схемы модуля и двух членов этого модуля.  
  
 [!CODE [VbVbalrDeclaredElements#1](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrDeclaredElements#1)]  
  
 В пределах `projModule` элементы программирования, объявленные на уровне модуля, продвигаются до уровня `projNamespace`.  В предыдущем примере `basicEnum` и `innerClass` продвигаются, а `numberSub` — нет, поскольку он не объявлен на уровне модуля.  
  
## Эффект повышения типа  
 Эффект повышения типа заключается в том, что в квалификационную строку не нужно включать имя модуля.  В приведенном ниже примере выполняется два вызова процедуры из предыдущего примера.  
  
 [!CODE [VbVbalrDeclaredElements#2](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrDeclaredElements#2)]  
  
 В предыдущем примере для первого вызова используются полные квалификационные строки.  Однако это не обязательно, поскольку применяется повышение типа.  Во втором вызове также присутствует обращение к членам модуля, но без включения `projModule` в строки квалификации.  
  
## Отмена повышения типа  
 Если в пространстве имен уже имеется член, имя которого совпадает с именем члена модуля, повышение типа для члена модуля отменяется.  В приведенном ниже примере показано определение схемы перечисления и модуль в рамках одного пространства имен.  
  
 [!CODE [VbVbalrDeclaredElements#3](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrDeclaredElements#3)]  
  
 В предыдущем примере [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] не удается повысить уровень класса `abc` до уровня `thisNameSpace`, поскольку уже существует перечисление с тем же именем на уровне пространства имен.  Чтобы получить доступ к `abcSub`, необходимо использовать полную квалификационную строку `thisNamespace.thisModule.abc.abcSub`.  Однако для класса `xyz` повышение уровня выполняется, и можно получить доступ к `xyzSub` с использованием укороченной квалификационной строки `thisNamespace.xyz.xyzSub`.  
  
### Отмена повышения типа для разделяемых типов  
 Если для класса или структуры внутри модуля используется ключевое слово [Partial](../../../../visual-basic/language-reference/modifiers/partial.md), повышение типа для этого класса или структуры автоматически отменяется независимо от того, имеется ли в пространстве имен член с тем же именем.  Для других элементов в модуле повышение типа по\-прежнему возможно.  
  
 **Последствия.** Отмена повышения типа для частично выполненного определения может привести к непредсказуемым результатам и даже ошибкам компилятора.  В приведенном ниже примере показана схема частично выполненных определений класса, одно из которых находится внутри модуля.  
  
 [!CODE [VbVbalrDeclaredElements#4](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrDeclaredElements#4)]  
  
 В предыдущем примере разработчик может ожидать, что компилятор выполнит слияние двух частично выполненных определений `sampleClass`.  Однако компилятор не примет во внимание повышение типа для частично выполненного определения внутри `sampleModule`.  В результате он попытается скомпилировать два отдельных и различных класса, имеющих одинаковое имя `sampleClass`, но с разными квалификационными путями.  
  
 Компилятор выполняет слияние частично выполненных определений только в том случае, если их полные пути одинаковы.  
  
## Рекомендации  
 Приведенные далее рекомендации даны на основании практического опыта программирования.  
  
-   **Уникальные имена.** Если имеется полный контроль над именованием элементов программирования, рекомендуется везде и всегда использовать уникальные имена.  Одинаковые имена требуют дополнительного уточнения и могут сделать код трудным для чтения.  Они также могут привести к непредсказуемым результатам и незаметным на первый взгляд ошибкам.  
  
-   **Полная квалификация.** При работе с модулями и другими элементами в одном пространстве имен безопаснее использовать полное определение для всех элементов программирования.  Если для члена модуля отменено повышение типа, и отсутствует полная квалификация этого члена, возможно случайное обращение к другому элементу программирования.  
  
## См. также  
 [Оператор Module](../../../../visual-basic/language-reference/statements/module-statement.md)   
 [Оператор Namespace](../../../../visual-basic/language-reference/statements/namespace-statement.md)   
 [Partial](../../../../visual-basic/language-reference/modifiers/partial.md)   
 [Область видимости в Visual Basic](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)   
 [Практическое руководство. Управление областью действия переменной](../../../../visual-basic/programming-guide/language-features/declared-elements/how-to-control-the-scope-of-a-variable.md)   
 [Ссылки на объявленные элементы](../../../../visual-basic/programming-guide/language-features/declared-elements/references-to-declared-elements.md)